<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>響屁一聲，迎新歲!</title>
    <style>
        /* 載入 Cubic_11 字體 */
        @font-face {
            font-family: 'Cubic_11';
            src: url('Cubic_11.woff');
            font-display: swap;
            font-weight: normal;
        }

        body {
            margin: 0; padding: 0; overflow: hidden; background-color: #1a0000;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; width: 100vw; touch-action: none;
        }

        /* --- 遊戲框架容器 --- */
        #game-frame {
            position: relative;
            width: auto; height: 100vh;
            aspect-ratio: 1080 / 1920;
            display: flex; justify-content: center; align-items: center;
            /* 優化：陰影移到外框，避免 Canvas 每一幀重繪陰影導致手機卡頓 */
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        canvas {
            width: 100%; height: 100%;
            display: block;
            background-color: #1a0000;
        }

        /* UI 層設定 */
        #ui {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            pointer-events: none; z-index: 10;
            font-family: 'Cubic_11', 'Microsoft JhengHei', sans-serif;
            text-align: center;
        }

        /* --- Logo 與 Glow 特效 --- */
        #logo-container {
            position: relative;
            width: 85%;
            display: flex; justify-content: center; align-items: center;
            margin-bottom: 10px;
        }

        #logo-glow {
            position: absolute;
            width: 200%; height: 200%; 
            top: -50%; left: -50%;
            background: radial-gradient(circle, rgba(255, 255, 200, 0.7) 0%, rgba(255, 255, 200, 0) 55%);
            animation: glow-pulse 3s ease-in-out infinite;
            pointer-events: none; z-index: -1;
        }

        #game-logo {
            width: 100%; height: auto;
            display: block;
            animation: logo-float 3s ease-in-out infinite;
        }

        @keyframes glow-pulse {
            0%, 100% { opacity: 0.4; transform: scale(1.1); }
            50% { opacity: 0.8; transform: scale(1.4); }
        }

        @keyframes logo-float {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-30px) scale(1.02); }
        }

        /* --- LOADING 頁面 --- */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: #1a0000; background-image: url('loading_BG.svg');
            background-size: contain; background-position: center; background-repeat: no-repeat;
            display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 500;
            color: #ffffff; font-family: 'Cubic_11', sans-serif;
            transition: opacity 0.4s ease; cursor: pointer;
        }
        .loader-bar { width: 300px; height: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 20px; margin-top: 30px; overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.3); }
        #loader-fill { width: 0%; height: 100%; background: #acff00; transition: width 0.1s; box-shadow: 0 0 10px #acff00; }
        #loading-text { font-size: 40px; font-weight: bold; text-align: center; color: #ffffff; margin-bottom: 5px; }

        /* --- 文字樣式 --- */
        h1 { 
            font-size: 80px; margin: 0; font-weight: bold; color: #ffcc00; 
            -webkit-text-stroke: 12px #3d231a; paint-order: stroke fill; 
            stroke-linejoin: round; -webkit-stroke-linejoin: round;
            letter-spacing: 5px; line-height: 1.2; width: 100%; 
        }
        h1 span { 
            font-size: 40px; -webkit-text-stroke: 7px #3d231a; 
            stroke-linejoin: round; -webkit-stroke-linejoin: round;
            display: block; margin-top: 10px; width: 100%; 
        }
        p { 
            font-size: 40px; margin: 20px 0 0 0; color: #ffffff; font-weight: bold; 
            -webkit-text-stroke: 8px #3d231a; paint-order: stroke fill; 
            stroke-linejoin: round; -webkit-stroke-linejoin: round;
            width: 100%; line-height: 1.5; 
        }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div id="loading-text">LOADING... 0%</div>
        <div class="loader-bar"><div id="loader-fill"></div></div>
    </div>

    <div id="game-frame">
        <div id="ui">
            <div id="logo-container" style="display: none;">
                <div id="logo-glow"></div>
                <img id="game-logo" src="logo.png">
            </div>
            
            <h1 id="msg" style="display: none;"></h1>
            <p id="subMsg">點擊畫面 開始比賽</p>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const msg = document.getElementById('msg');
        const subMsg = document.getElementById('subMsg');
        const logoContainer = document.getElementById('logo-container');
        const loaderScreen = document.getElementById('loading-screen');
        const loaderFill = document.getElementById('loader-fill');
        const loaderText = document.getElementById('loading-text');

        canvas.width = 1080;
        canvas.height = 1920;

        const assets = {
            images: { idle: 'char_idle.png', fart: 'char_fart.png', pillar: 'pillar.png', bg: 'background.jpg', red: 'redpocket.png', lbg: 'loading_BG.svg', logo: 'logo.png' }
        };

        const imageFiles = Object.values(assets.images);
        let totalToLoad = imageFiles.length;
        let loadedCount = 0;
        let isReady = false;

        function updateLoader() {
            if (isReady) return;
            loadedCount++;
            let progress = Math.min(Math.floor((loadedCount / totalToLoad) * 100), 100);
            loaderFill.style.width = progress + '%';
            loaderText.innerText = `LOADING... ${progress}%`;
            if (loadedCount >= totalToLoad) setReady();
        }

        function setReady() {
            if (isReady) return;
            isReady = true;
            loaderFill.style.width = '100%';
            loaderText.innerHTML = "準備就緒，<br>點擊參賽！";
        }

        const imgIdle = new Image(); imgIdle.onload = updateLoader; imgIdle.src = 'char_idle.png';
        const imgFart = new Image(); imgFart.onload = updateLoader; imgFart.src = 'char_fart.png';
        const imgPillar = new Image(); imgPillar.onload = updateLoader; imgPillar.src = 'pillar.png';
        const imgRed = new Image(); imgRed.onload = updateLoader; imgRed.src = 'redpocket.png';
        const imgLBG = new Image(); imgLBG.onload = updateLoader; imgLBG.src = 'loading_BG.svg';
        const imgLOGO = new Image(); imgLOGO.onload = updateLoader; imgLOGO.src = 'logo.png';
        let bgRenderWidth = 1080;
        const imgBG = new Image();
        imgBG.onload = () => { bgRenderWidth = imgBG.width * (canvas.height / imgBG.height); updateLoader(); };
        imgBG.src = 'background.jpg';

        const fartSound = new Audio('fart.mp3');
        const collectSound = new Audio('collect.mp3');
        const bgm = new Audio('bgm.mp3');
        bgm.loop = true; bgm.volume = 0.2;

        let gameState = 'LOADING';
        let frames = 0, score = 0, bgX = 0, lastStateChange = 0;
        let particles = [], redPockets = [];
        const bgSpeed = 4;

        class RedPocket {
            constructor(x, y) { this.x = x; this.y = y; this.w = 300; this.h = 336; this.floatAngle = 0; this.pulseAngle = 0; this.active = true; }
            update() {
                if (gameState === 'PLAYING') this.x -= 10;
                this.floatAngle += 0.05; this.pulseAngle += 0.08;
                this.offsetY = Math.sin(this.floatAngle) * 35;
                this.glowRadius = 160 + Math.sin(this.pulseAngle) * 40;
            }
            draw() {
                if (!this.active) return;
                ctx.save();
                const centerX = this.x + this.w / 2; const centerY = this.y + this.h / 2 + this.offsetY;
                const gradient = ctx.createRadialGradient(centerX, centerY, 50, centerX, centerY, this.glowRadius);
                gradient.addColorStop(0, "rgba(255, 255, 200, 0.6)"); gradient.addColorStop(1, "rgba(255, 255, 200, 0)");
                ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(centerX, centerY, this.glowRadius, 0, Math.PI * 2); ctx.fill();
                ctx.drawImage(imgRed, this.x, this.y + this.offsetY, this.w, this.h); ctx.restore();
            }
        }

        const uncle = {
            x: 150, y: 800, base_y: 800, w: 310, h: 324, gravity: 1.45, jump: 33, velocity: 0, isFarting: false, fartTimer: 0,
            draw() {
                const currentImg = this.isFarting ? imgFart : imgIdle;
                let currentAngle = 0;
                if (this.isFarting) currentAngle = (this.fartTimer / 21) * 0.2; 
                ctx.save();
                ctx.translate(this.x + this.w / 2, this.y + this.h / 2);
                ctx.rotate(currentAngle);
                ctx.drawImage(currentImg, -this.w / 2, -this.h / 2, this.w, this.h);
                ctx.restore();
                // 注意：fartTimer 邏輯移到 update 中處理，這裡只負責畫圖
            },
            update() {
                // 減少 fartTimer 的邏輯移到這裡
                if (this.isFarting) { this.fartTimer--; if (this.fartTimer <= 0) this.isFarting = false; }

                if (gameState === 'START' || gameState === 'LOADING') { this.y = this.base_y + Math.sin(frames * 0.05) * 20; return; }
                this.velocity += this.gravity; this.y += this.velocity;
                if (gameState === 'PLAYING') {
                    if (this.y > canvas.height) gameOver();
                    redPockets.forEach(rp => {
                        if (rp.active && this.x + 50 < rp.x + rp.w && this.x + this.w > rp.x && this.y + 50 < rp.y + rp.h + rp.offsetY && this.y + this.h - 50 > rp.y + rp.offsetY) {
                            rp.active = false; score += 5; collectSound.currentTime = 0; collectSound.play().catch(()=>{});
                        }
                    });
                }
            },
            flap() {
                this.velocity = -this.jump; this.isFarting = true; this.fartTimer = 21; 
                fartSound.currentTime = 0; fartSound.play().catch(()=>{});
                // 優化：減少粒子數量，從 45 減到 25，減輕手機負擔
                for(let i = 0; i < 25; i++) {
                    particles.push({ x: this.x + 60, y: this.y + this.h - 110, size: Math.random() * 60 + 30, speedX: Math.random() * -20 - 10, speedY: Math.random() * 12 - 6, opacity: 1, color: ['#FFF0F5', '#FFE4E1', '#FFD1DC', '#FFC0CB'][Math.floor(Math.random()*4)] });
                }
            }
        };

        const pipes = {
            list: [], width: 240, speed: 10,
            update() {
                if (gameState !== 'PLAYING') return;
                // 注意：邏輯更新頻率固定，這裡的 frames 已經很穩定
                if (frames % 110 === 0 && frames > 10) {
                    let gap = Math.random() * 150 + 600;
                    let top = Math.random() * (canvas.height - gap - 800) + 300;
                    this.list.push({ x: canvas.width, top: top, gap: gap });
                    if (Math.random() < 0.6) redPockets.push(new RedPocket(canvas.width + 550, top + gap / 2 - 168));
                }
                this.list.forEach((p, index) => {
                    p.x -= this.speed;
                    if (uncle.x + 95 < p.x + this.width && uncle.x + uncle.w - 95 > p.x) {
                        if (uncle.y + 95 < p.top || uncle.y + uncle.h - 95 > p.top + p.gap) gameOver();
                    }
                    if (p.x + this.width < 0) { this.list.splice(index, 1); score++; }
                });
            }
        };

        function gameOver() { 
            if (gameState === 'GAMEOVER') return; 
            gameState = 'GAMEOVER'; lastStateChange = Date.now();
            logoContainer.style.display = 'none'; msg.style.display = 'block';
            let rankText = (score >= 60) ? "屁王萬歲萬萬歲！" : (score >= 50) ? "屁王是你嗎？！" : (score >= 20) ? "咁易就放屁喇？" : (score >= 10) ? "五月一齊放屁" : "廢到屁視你";
            msg.innerHTML = `不舒適人<br><span>${rankText}</span>`; 
            subMsg.innerHTML = `總得分: ${score}<br>點擊再放多次！`; 
            bgm.volume = 0.1; 
        }

        function showTitleScreen() {
            gameState = 'START'; lastStateChange = Date.now();
            logoContainer.style.display = 'flex'; msg.style.display = 'none';
            subMsg.innerHTML = "點擊畫面 開始比賽";
            pipes.list = []; redPockets = []; particles = [];
            bgm.volume = 0.2; bgm.play().catch(()=>{});
        }

        function resetGame() { 
            uncle.y = 800; uncle.velocity = 0; uncle.isFarting = false;
            pipes.list = []; redPockets = []; particles = []; score = 0; frames = 0;
            gameState = 'PLAYING'; lastStateChange = Date.now();
            logoContainer.style.display = 'none'; msg.style.display = 'none';
            subMsg.innerHTML = ""; bgm.volume = 0.2; bgm.play().catch(()=>{});
            uncle.flap();
        }

        function globalInput(e) {
            if (e.type === 'touchstart') e.preventDefault();
            const now = Date.now();
            if (!isReady) return;
            if (gameState === 'LOADING') {
                loaderScreen.style.opacity = '0';
                setTimeout(() => { loaderScreen.style.display = 'none'; showTitleScreen(); }, 400);
                return;
            }
            if (now - lastStateChange < 450) return;
            if (gameState === 'START') resetGame();
            else if (gameState === 'PLAYING') uncle.flap();
            else if (gameState === 'GAMEOVER' && uncle.y > canvas.height) showTitleScreen();
        }

        window.addEventListener('mousedown', globalInput);
        window.addEventListener('touchstart', globalInput, {passive: false});

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) { bgm.pause(); } 
            else if (gameState !== 'LOADING') { bgm.play().catch(() => {}); }
        });

        // ==========================================
        //  核心優化：固定時間步長 (Fixed Time Step)
        // ==========================================
        
        // 我們將「運算」跟「畫圖」分開
        // 運算：永遠每秒跑 60 次 (16.66ms 一次)，保證物理速度一致
        // 畫圖：能跑多快跑多快
        
        let lastTime = Date.now();
        let accumulator = 0;
        const step = 1000 / 60; // 固定每一幀的邏輯時間 (16.66ms)

        // 這裡只放「純數學運算」，不畫圖
        function updateGameLogic() {
            if (gameState === 'PLAYING') { 
                bgX -= bgSpeed; 
                if (bgX <= -bgRenderWidth) bgX = 0; 
            }
            
            pipes.update();
            redPockets.forEach((rp, index) => { rp.update(); if (rp.x < -400) redPockets.splice(index, 1); });
            
            for (let i = 0; i < particles.length; i++) {
                let p = particles[i]; 
                if (gameState === 'PLAYING') p.x += p.speedX; 
                p.y += p.speedY; 
                p.opacity -= 0.02;
                if (p.opacity <= 0) { particles.splice(i, 1); i--; }
            }
            
            uncle.update();
            frames++;
        }

        // 這裡只放「畫圖」，不運算位置
        function drawGameRender() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 背景
            ctx.drawImage(imgBG, bgX, 0, bgRenderWidth, canvas.height); 
            ctx.drawImage(imgBG, bgX + bgRenderWidth, 0, bgRenderWidth, canvas.height);
            
            // 柱子
            pipes.list.forEach(p => {
                ctx.drawImage(imgPillar, p.x, p.top + p.gap, pipes.width, 1600);
                ctx.save(); ctx.translate(p.x + pipes.width/2, p.top); ctx.scale(1, -1);
                ctx.drawImage(imgPillar, -pipes.width/2, 0, pipes.width, 1600); ctx.restore();
            });
            
            // 紅包
            redPockets.forEach(rp => rp.draw());
            
            // 粒子
            for (let i = 0; i < particles.length; i++) {
                let p = particles[i];
                ctx.save(); ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, p.opacity); 
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();
            }
            
            // 主角
            uncle.draw();
            
            // 分數
            if (gameState === 'PLAYING') {
                const scoreText = `得分: ${score}`;
                ctx.font = "bold 55px 'Cubic_11', sans-serif";
                ctx.lineJoin = "round"; ctx.miterLimit = 2; ctx.strokeStyle = "#3d231a"; ctx.lineWidth = 14; 
                ctx.strokeText(scoreText, 80, 120); ctx.fillStyle = "#ffcc00"; ctx.fillText(scoreText, 80, 120);
            }
        }

        function loop() {
            requestAnimationFrame(loop);

            let now = Date.now();
            let frameTime = now - lastTime;
            lastTime = now;

            // 如果手機卡住太久（例如切換分頁），限制最大補償時間，避免一次跑幾百次運算導致卡死
            if (frameTime > 100) frameTime = 100; 

            accumulator += frameTime;

            // 只要累積的時間夠多，就跑運算
            // 這保證了不管螢幕多快多慢，物理移動的速度都是依照 "step" (1/60秒) 進行的
            while (accumulator >= step) {
                updateGameLogic();
                accumulator -= step;
            }

            // 運算完位置後，再畫圖
            drawGameRender();
        }

        loop();
    </script>
</body>
</html>